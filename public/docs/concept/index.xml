<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bRPC – 架构原理</title>
    <link>https://brpc.incubator.apache.org/docs/concept/</link>
    <description>Recent content in 架构原理 on bRPC</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 04 Jan 2017 00:00:00 +0000</lastBuildDate>
    
	  <atom:link href="https://brpc.incubator.apache.org/docs/concept/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: MOSN 核心概念</title>
      <link>https://brpc.incubator.apache.org/docs/concept/core-concept/</link>
      <pubDate>Sun, 20 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/concept/core-concept/</guid>
      <description>
        
        
        &lt;p&gt;MOSN 主要划分为如下模块，包括了网络代理具备的基础能力，也包含了 &lt;a href=&#34;https://www.servicemesher.com/blog/envoy-xds-protocol/&#34;&gt;xDS&lt;/a&gt; 等云原生能力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;mosn-modules-arch.jpg&#34; alt=&#34;MOSN 模块大图&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;xdsudpa支持&#34;&gt;xDS（UDPA）支持&lt;/h2&gt;
&lt;p&gt;MOSN 支持云原生&lt;a href=&#34;https://github.com/cncf/udpa&#34;&gt;统一数据面 API（UDPA）&lt;/a&gt;，支持全动态配置更新。&lt;/p&gt;
&lt;p&gt;xDS 是 &lt;a href=&#34;https://www.envoyproxy.io/&#34;&gt;Envoy&lt;/a&gt; 创建的一个关键概念，它是一类发现服务的统称，其包括如下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CDS：Cluster Discovery Service&lt;/li&gt;
&lt;li&gt;EDS：Endpoint Discovery Service&lt;/li&gt;
&lt;li&gt;SDS：Secret Discovery Service&lt;/li&gt;
&lt;li&gt;RDS：Route Discovery Service&lt;/li&gt;
&lt;li&gt;LDS：Listener Discovery Service&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正是通过对 xDS 的请求来动态更新 Envoy 配置，另外还有个 ADS（Aggregated Discovery Service）通过聚合的方式解决以上 xDS 的更新顺序问题。&lt;/p&gt;
&lt;h2 id=&#34;业务支持&#34;&gt;业务支持&lt;/h2&gt;
&lt;p&gt;MOSN 作为底层的高性能安全网络代理，支撑了 RPC、消息（Messaging）、网关（Gateway）等业务场景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;mosn-core.jpg&#34; alt=&#34;MOSN 业务支持&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;io-模型&#34;&gt;IO 模型&lt;/h2&gt;
&lt;p&gt;MOSN 支持以下两种 IO 模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Golang 经典 netpoll 模型&lt;/strong&gt;：goroutine-per-connection，适用于在连接数不是瓶颈的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RawEpoll 模型&lt;/strong&gt;：也就是 Reactor 模式，I/O 多路复用（I/O multiplexing）+ 非阻塞 I/O（non-blocking I/O）的模式。对于接入层和网关有大量长链接的场景，更加适合于 RawEpoll 模型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;netpoll-模型&#34;&gt;netpoll 模型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;netpoll-model.jpg&#34; alt=&#34;MOSN netpoll 模型&#34;&gt;&lt;/p&gt;
&lt;p&gt;MOSN 的 netpoll 模型如上图所示，协程数量与链接数量成正比，大量链接场景下，协程数量过多，存在以下开销：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stack 内存开销&lt;/li&gt;
&lt;li&gt;Read buffer 开销&lt;/li&gt;
&lt;li&gt;Runtime 调度开销&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rawepoll-模型&#34;&gt;RawEpoll 模型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;raw-epoll-model.jpg&#34; alt=&#34;MOSN RawEpoll 模型&#34;&gt;&lt;/p&gt;
&lt;p&gt;RawEpoll 模型如上图所示，使用 epoll 感知到可读事件之后，再从协程池中为其分配协程进行处理，步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;链接建立后，向 Epoll 注册 oneshot 可读事件监听；并且此时不允许有协程调用 conn.read，避免与 runtime netpoll 冲突。&lt;/li&gt;
&lt;li&gt;可读事件到达，从 goroutine pool 挑选一个协程进行读事件处理；由于使用的是 oneshot 模式，该 fd 后续可读事件不会再触发。&lt;/li&gt;
&lt;li&gt;请求处理过程中，协程调度与经典 netpoll 模式一致。&lt;/li&gt;
&lt;li&gt;请求处理完成，将协程归还给协程池；同时将 fd 重新添加到 RawEpoll 中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;协程模型&#34;&gt;协程模型&lt;/h2&gt;
&lt;p&gt;MOSN 的协程模型如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;mosn-goroutine-model.jpg&#34; alt=&#34;MSON 协程模型&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一条 TCP 连接对应一个 Read 协程，执行收包、协议解析；&lt;/li&gt;
&lt;li&gt;一个请求对应一个 worker 协程，执行业务处理，proxy 和 Write 逻辑；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常规模型一个 TCP 连接将有 Read/Write 两个协程，我们取消了单独的 Write 协程，让 workerpool 工作协程代替，减少了调度延迟和内存占用。&lt;/p&gt;
&lt;h2 id=&#34;能力扩展&#34;&gt;能力扩展&lt;/h2&gt;
&lt;h3 id=&#34;协议扩展&#34;&gt;协议扩展&lt;/h3&gt;
&lt;p&gt;MOSN 通过使用统一的编解码引擎以及编/解码器核心接口，提供协议的 plugin 机制，包括支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SOFARPC&lt;/li&gt;
&lt;li&gt;HTTP1.x/HTTP2.0&lt;/li&gt;
&lt;li&gt;Dubbo&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;networkfilter-扩展&#34;&gt;NetworkFilter 扩展&lt;/h3&gt;
&lt;p&gt;MOSN 通过提供 network filter 注册机制以及统一的 packet read/write filter 接口，实现了 Network filter 扩展机制，当前支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP proxy&lt;/li&gt;
&lt;li&gt;Fault injection&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;streamfilter-扩展&#34;&gt;StreamFilter 扩展&lt;/h3&gt;
&lt;p&gt;MOSN 通过提供 stream filter 注册机制以及统一的 stream send/receive filter 接口，实现了 Stream filter 扩展机制，包括支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流量镜像&lt;/li&gt;
&lt;li&gt;RBAC 鉴权&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tls-安全链路&#34;&gt;TLS 安全链路&lt;/h2&gt;
&lt;p&gt;通过测试，原生的 Go 的 TLS 经过了大量的汇编优化，在性能上是 Nginx（OpenSSL）的80%，Boring 版本的 Go（使用 cgo 调用 BoringSSL）因为 cgo 的性能问题， 并不占优势，所以我们最后选择使用原生 Go 的 TLS，相信 Go Runtime 团队后续会有更多的优化，我们也会有一些优化计划。&lt;/p&gt;
&lt;p&gt;Go vs Nginx 测试结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;mosn-tls-1.png&#34; alt=&#34;Go vs Nginx TLS 性能&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Go 在 RSA 上没有太多优化，go-boring（CGO）的能力是 Go 的两倍。&lt;/li&gt;
&lt;li&gt;p256 在 Go 上有汇编优化，ECDSA 优于go-boring。&lt;/li&gt;
&lt;li&gt;在 AES-GCM 对称加密上，Go 的能力是 go-boring 的 20 倍。&lt;/li&gt;
&lt;li&gt;在 SHA、MD 等 HASH 算法也有对应的汇编优化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了满足金融场景的安全合规，我们同时也对国产密码进行了开发支持，这个是 Go Runtime 所没有的。虽然目前的性能相比国际标准 AES-GCM 还是有一些差距，大概是 50%，但是我们已经有了后续的一些优化计划，敬请期待。&lt;/p&gt;
&lt;p&gt;支持国密的性能测试结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;mosn-tls-2.png&#34; alt=&#34;支持国密的性能测试&#34;&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Sidecar 模式</title>
      <link>https://brpc.incubator.apache.org/docs/concept/sidecar-pattern/</link>
      <pubDate>Sun, 20 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/concept/sidecar-pattern/</guid>
      <description>
        
        
        &lt;p&gt;Sidecar 模式是 Service Mesh 中习惯采用的模式，是容器设计模式的一种，在 Service Mesh 出现之前该模式就一直存在，本文将为您讲解 Sidecar 模式。&lt;/p&gt;
&lt;h2 id=&#34;什么是-sidecar-模式&#34;&gt;什么是 Sidecar 模式&lt;/h2&gt;
&lt;p&gt;将应用程序的功能划分为单独的进程可以被视为 &lt;strong&gt;Sidecar 模式&lt;/strong&gt;。如图所示，Sidecar 模式允许您在应用程序旁边添加更多功能，而无需额外第三方组件配置或修改应用程序代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;sidecar-pattern.jpg&#34; alt=&#34;Sidecar 模式&#34;&gt;&lt;/p&gt;
&lt;p&gt;就像连接了 Sidecar 的三轮摩托车一样，在软件架构中， Sidecar 连接到父应用并且为其添加扩展或者增强功能。Sidecar 应用与主应用程序松散耦合。它可以屏蔽不同编程语言的差异，统一实现微服务的可观察性、监控、日志记录、配置、断路器等功能。&lt;/p&gt;
&lt;h2 id=&#34;使用-sidecar-模式的优势&#34;&gt;使用 Sidecar 模式的优势&lt;/h2&gt;
&lt;p&gt;Sidecar 模式具有以下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将与应用业务逻辑无关的功能抽象到共同基础设施降低了微服务代码的复杂度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为不再需要编写相同的第三方组件配置文件和代码，所以能够降低微服务架构中的代码重复度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;降低应用程序代码和底层平台的耦合度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sidecar-模式如何工作&#34;&gt;Sidecar 模式如何工作&lt;/h2&gt;
&lt;p&gt;Sidecar 是容器应用模式的一种，也是在 Service Mesh 中发扬光大的一种模式，详见 &lt;a href=&#34;https://www.servicemesher.com/blog/service-mesh-architectures/&#34;&gt;Service Mesh 架构解析&lt;/a&gt;，其中详细描述使用了&lt;strong&gt;节点代理&lt;/strong&gt;和 &lt;strong&gt;Sidecar&lt;/strong&gt; 模式的 Service Mesh 架构。&lt;/p&gt;
&lt;p&gt;使用 Sidecar 模式部署服务网格时，无需在节点上运行代理，但是集群中将运行多个相同的 Sidecar 副本。在 Sidecar 部署方式中，每个应用的容器旁都会部署一个伴生容器，这个容器称之为 Sidecar 容器。Sidecar 接管进出应用容器的所有流量。在 Kubernetes 的 Pod 中，在原有的应用容器旁边注入一个 Sidecar 容器，两个容器共享存储、网络等资源，可以广义的将这个包含了 Sidecar 容器的 Pod 理解为一台主机，两个容器共享主机资源。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 流量劫持</title>
      <link>https://brpc.incubator.apache.org/docs/concept/traffic-hijack/</link>
      <pubDate>Mon, 20 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/concept/traffic-hijack/</guid>
      <description>
        
        
        &lt;p&gt;本文描述的是 MOSN 作为 Sidecar 使用时的流量劫持方案。&lt;/p&gt;
&lt;p&gt;MOSN 作为 Sidecar 和业务容器部署在同一个 Pod 中时，需要使得业务应用的 Inbound 和 Outbound 服务请求都能够经过 Sidecar 处理。区别于 Istio 社区使用 iptables 做流量透明劫持，MOSN 目前使用的是流量接管方案，并在积极探索适用于大规模流量下的透明劫持方案。&lt;/p&gt;
&lt;h2 id=&#34;流量接管&#34;&gt;流量接管&lt;/h2&gt;
&lt;p&gt;区别于 Istio 社区的 &lt;a href=&#34;https://jimmysong.io/istio-handbook/concepts/sidecar-injection-deep-dive.html&#34;&gt;iptables 流量劫持方案&lt;/a&gt;，MOSN 使用的流量接管的方案如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;假设服务端运行在 1.2.3.4 这台机器上，监听 20880 端口，首先服务端会向自己的 Sidecar 发起服务注册请求，告知 Sidecar 需要注册的服务以及 IP + 端口（1.2.3.4:20880）&lt;/li&gt;
&lt;li&gt;服务端的 Sidecar 会向服务注册中心（如 SOFA Registry）发起服务注册请求，告知需要注册的服务以及 IP + 端口，不过这里需要注意的是注册上去的并不是业务应用的端口（20880），而是 Sidecar 自己监听的一个端口（例如：20881）&lt;/li&gt;
&lt;li&gt;调用端向自己的 Sidecar 发起服务订阅请求，告知需要订阅的服务信息&lt;/li&gt;
&lt;li&gt;调用端的 Sidecar 向调用端推送服务地址，这里需要注意的是推送的 IP 是本机，端口是调用端的 Sidecar 监听的端口（例如 20882）&lt;/li&gt;
&lt;li&gt;调用端的 Sidecar 会向服务注册中心（如 SOFA Registry）发起服务订阅请求，告知需要订阅的服务信息；&lt;/li&gt;
&lt;li&gt;服务注册中心（如 SOFA Registry）向调用端的 Sidecar 推送服务地址（1.2.3.4:20881）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;traffic-hijacking.png&#34; alt=&#34;流量接管示意图&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;服务调用过程&#34;&gt;服务调用过程&lt;/h3&gt;
&lt;p&gt;经过上述的服务发现过程，流量转发过程就显得非常自然了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用端拿到的服务端地址是 &lt;code&gt;127.0.0.1:20882&lt;/code&gt;，所以就会向这个地址发起服务调用&lt;/li&gt;
&lt;li&gt;调用端的 Sidecar 接收到请求后，通过解析请求头，可以得知具体要调用的服务信息，然后获取之前从服务注册中心返回的地址后就可以发起真实的调用（&lt;code&gt;1.2.3.4:20881&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;服务端的 Sidecar 接收到请求后，经过一系列处理，最终会把请求发送给服务端（&lt;code&gt;127.0.0.1:20880&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;service-call-process.png&#34; alt=&#34;服务调用过程示意图&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;透明劫持&#34;&gt;透明劫持&lt;/h2&gt;
&lt;p&gt;上文通过在服务注册过程中把服务端地址替换成本机监听端口实现了轻量级的“流量劫持”，在存在注册中心，且调用端和服务端同时使用特定SDK的场景中可以很好的工作，如果不满足这两个条件，则无法流量劫持。为了降低对于应用程序的要求，需要引入透明劫持。&lt;/p&gt;
&lt;h3 id=&#34;使用-iptables-做流量劫持&#34;&gt;使用 iptables 做流量劫持&lt;/h3&gt;
&lt;p&gt;iptables 通过 NAT 表的 redirect 动作执行流量重定向，通过 syn 包触发新建 nefilter 层的连接，后续报文到来时查找连接转换目的地址与端口。新建连接时同时会记录下原始目的地址，应用程序可以通过(&lt;code&gt;SOL_IP&lt;/code&gt;、&lt;code&gt;SO_ORIGINAL_DST&lt;/code&gt;)获取到真实的目的地址。&lt;/p&gt;
&lt;p&gt;iptables 劫持原理如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;iptables.png&#34; alt=&#34;iptables 劫持原理&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;使用-iptables-做流量劫持时存在的问题&#34;&gt;使用 iptables 做流量劫持时存在的问题&lt;/h3&gt;
&lt;p&gt;目前 Istio 使用 iptables 实现透明劫持，主要存在以下三个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要借助于 conntrack 模块实现连接跟踪，在连接数较多的情况下，会造成较大的消耗，同时可能会造成 track 表满的情况，为了避免这个问题，业内有关闭 conntrack 的做法。&lt;/li&gt;
&lt;li&gt;iptables 属于常用模块，全局生效，不能显式的禁止相关联的修改，可管控性比较差。&lt;/li&gt;
&lt;li&gt;iptables 重定向流量本质上是通过 loopback 交换数据，outbond 流量将两次穿越协议栈，在大并发场景下会损失转发性能。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述几个问题并非在所有场景中都存在，比方说某些场景下，连接数并不多，且 NAT 表未被使用到的情况下，iptables 是一个满足要求的简单方案。为了适配更加广泛的场景，透明劫持需要解决上述三个问题。&lt;/p&gt;
&lt;h3 id=&#34;透明劫持方案优化&#34;&gt;透明劫持方案优化&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用 tproxy 处理 inbound 流量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;tproxy 可以用于 inbound 流量的重定向，且无需改变报文中的目的 IP/端口，不需要执行连接跟踪，不会出现 conntrack 模块创建大量连接的问题。受限于内核版本，tproxy 应用于 outbound 存在一定缺陷。目前 Istio 支持通过 tproxy 处理 inbound 流量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用 hook connect 处理 outbound 流量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了适配更多应用场景，outbound 方向通过 hook connect 来实现，实现原理如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;hook-connect.png&#34; alt=&#34;hook-connect 原理示意图&#34;&gt;&lt;/p&gt;
&lt;p&gt;无论采用哪种透明劫持方案，均需要解决获取真实目的 IP/端口的问题，使用 iptables 方案通过 getsockopt 方式获取，tproxy 可以直接读取目的地址，通过修改调用接口，hook connect 方案读取方式类似于tproxy。&lt;/p&gt;
&lt;p&gt;实现透明劫持后，在内核版本满足要求（4.16以上）的前提下，通过 sockmap 可以缩短报文穿越路径，进而改善 outbound 方向的转发性能。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;总结来看，如果应用程序通过注册中心发布/订阅服务时，可以结合注册中心劫持流量；在需要用到透明劫持的场景，如果性能压力不大，使用 iptables redirect 即可，大并发压力下使用 tproxy 与hook connect 结合的方案。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: TLS 安全链路</title>
      <link>https://brpc.incubator.apache.org/docs/concept/tls/</link>
      <pubDate>Mon, 20 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/concept/tls/</guid>
      <description>
        
        
        &lt;p&gt;本文将向您展示 MOSN 的 TLS 安全能力。&lt;/p&gt;
&lt;h2 id=&#34;证书方案&#34;&gt;证书方案&lt;/h2&gt;
&lt;p&gt;MOSN 支持通过 Istio Citadel 的证书签发方案，基于 Istio 社区的 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret&#34;&gt;SDS （Secret Discovery Service）&lt;/a&gt;方案为 Sidecar 配置证书，支持证书动态发现和热更新能力。为了支持更高级的安全能力，MOSN 没有使用 Citadel 的证书自签发能力，而是通过对接内部 KMS 系统获取证书。同时提供证书缓存和证书推送更新能力。&lt;/p&gt;
&lt;p&gt;我们先来看看 MOSN 证书方案的架构图，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;mosn-certificate-arch.png&#34; alt=&#34;MOSN 证书方案&#34;&gt;&lt;/p&gt;
&lt;p&gt;各组件职能如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pilot：负责 Policy、SDS 配置下发，为简化复杂度，图中未标出&lt;/li&gt;
&lt;li&gt;Citadel：Citadel 作为 Certificate Provider ，同时作为 MCP Server 为 Citadel Agent 提供 Pod、CR等资源&lt;/li&gt;
&lt;li&gt;Citadel Agent：提供 SDS Server 服务，为MOSN、DB Sidecar、Security Sidecar 提供Certificate和CR下发能力&lt;/li&gt;
&lt;li&gt;KMS：密钥管理系统负责证书签发&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;证书获取流程&#34;&gt;证书获取流程&lt;/h3&gt;
&lt;p&gt;对整体架构有个大致理解后，我们分解下 Sidecar 获取证书的流程，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;certificate-request-process.png&#34; alt=&#34;证书获取流程&#34;&gt;&lt;/p&gt;
&lt;p&gt;补充说明下图中的每一步环节：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Citadel 与 Citadel agent（nodeagent）组件通过MCP协议（Mesh Configuration Protocol）同步Pod 和 CR 信息，避免 citadel agent 直接请求 API Server 导致 API Server 负载过高&lt;/li&gt;
&lt;li&gt;MOSN 通过Unix Domain Socket 方式向 Citadel Agent 发起 SDS 请求&lt;/li&gt;
&lt;li&gt;Citadel Agent 会进行防篡改校验，并提取appkey&lt;/li&gt;
&lt;li&gt;Citadel Agent 携带 appkey 请求 Citadel 签发证书&lt;/li&gt;
&lt;li&gt;Citadel 检查证书是否已缓存，如果缓存证书未过期，Citadel 将直接响应缓存证书&lt;/li&gt;
&lt;li&gt;证书不在缓存中，Citadel 会基于 appkey 构造证书签发请求，向 KMS 申请签发证书&lt;/li&gt;
&lt;li&gt;KMS 会将签发的证书响应回Citadel，另外 KMS 也支持证书过期轮换通知&lt;/li&gt;
&lt;li&gt;Citadel 收到证书后，会将证书传递给到对应的 Citadel Agent&lt;/li&gt;
&lt;li&gt;Citadel Agent 收到证书后，会在内存中缓存证书，并将证书下发给到 MOSN&lt;/li&gt;
&lt;/ol&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: MOSN 平滑升级原理解析</title>
      <link>https://brpc.incubator.apache.org/docs/concept/smooth-upgrade/</link>
      <pubDate>Mon, 20 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/concept/smooth-upgrade/</guid>
      <description>
        
        
        &lt;p&gt;Service Mesh 中 Sidecar 运维一直是一个比较棘手的问题，数据平面的 Sidecar 升级是常有的事情，如何在升级 Sidecar（MOSN）的时候而不影响业务，对于存量的长连接如何迁移，本文将为你介绍 MOSN 的解决之道。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;本文介绍 MOSN 支持平滑升级的原因和解决方案，对于平滑升级的一些基础概念，大家可以通过 &lt;a href=&#34;https://ms2008.github.io/2019/12/28/hot-upgrade/&#34;&gt;Nginx vs Enovy vs Mosn 平滑升级原理解析&lt;/a&gt;了解。&lt;/p&gt;
&lt;p&gt;先简单介绍一下为什么 Nginx 和 Envoy 不需要具备 MOSN 这样的连接无损迁移方案，主要还是跟业务场景相关，Nginx 和 Envoy 主要支持的是 HTTP1 和 HTTP2 协议，HTTP1使用 connection: Close，HTTP2 使用 Goaway Frame 都可以让 Client 端主动断链接，然后新建链接到新的 New process，但是针对 Dubbo、SOFA PRC 等常见的多路复用协议，它们是没有控制帧，Old process 的链接如果断了就会影响请求的。&lt;/p&gt;
&lt;p&gt;一般的升级做法就是切走应用的流量，比如自己UnPub掉服务，等待一段时间没有请求之后，升级MOSN，升级好之后再Pub服务，整个过程比较耗时，并且会有一段时间是不提供服务的，还要考虑应用的水位，在大规模场景下，就很难兼顾评估。MOSN 为了满足自身业务场景，开发了长连接迁移方案，把这条链接迁移到 New process 上，整个过程对 Client 透明，不需要重新建链接，达到请求无损的平滑升级。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;reqeust-smooth-upgrade-process.png&#34; alt=&#34;MOSN 的请求无损的平滑升级过程&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;正常流程&#34;&gt;正常流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;normal-process.png&#34; alt=&#34;正常流程&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Client 发送请求 Request 到 MOSN&lt;/li&gt;
&lt;li&gt;MOSN 转发请求 Request 到 Server&lt;/li&gt;
&lt;li&gt;Server 回复响应 Response 到 MOSN&lt;/li&gt;
&lt;li&gt;MOSN 回复响应 Response 到 Client&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上图简单介绍了一个请求的正常流程，我们后面需要迁移的是 TCP1 链接，也就是 Client 到 MOSN 的连接，MOSN 到 Server 的链接 TCP2 不需要迁移，因为 MOSN 访问 Server 是根据 LoadBalance 选择，我们可以主动控制断链建链。&lt;/p&gt;
&lt;h2 id=&#34;平滑升级流程&#34;&gt;平滑升级流程&lt;/h2&gt;
&lt;h3 id=&#34;触发条件&#34;&gt;触发条件&lt;/h3&gt;
&lt;p&gt;有两个方式可以触发平滑升级流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MOSN 对 SIGHUP 做了监听，发送 SIGHUP 信号给 MOSN 进程，通过 ForkExec 生成一个新的 MOSN 进程。&lt;/li&gt;
&lt;li&gt;直接重新启动一个新 MOSN 进程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为什么提供两种方式？最开始我们支持的是方法1，也就是 nginx 和 Envoy 使用的方式，这个在虚拟机或者容器内替换 MOSN 二级制来升级是可行的，但是我们的场景需要满足容器间的升级，所以需要新拉起一个容器，就需要重新启动一个新的 MOSN 进程来做平滑升级，所以后续又支持了方法2。容器间升级还需要 operator 的支持，本文不展开叙述。&lt;/p&gt;
&lt;h3 id=&#34;交互流程&#34;&gt;交互流程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;interaction-process.png&#34; alt=&#34;交互流程&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;interaction-process-timeline.png&#34; alt=&#34;交互流程时序图&#34;&gt;&lt;/p&gt;
&lt;p&gt;首先，老的 MOSN 在启动最后阶段会启动一个协程运行 &lt;code&gt;ReconfigureHandler()&lt;/code&gt; 函数监听一个 Domain Socket（&lt;code&gt;reconfig.sock&lt;/code&gt;）, 该接口的作用是让新的 MOSN 来感知是否存在老的 MOSN。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ReconfigureHandler&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;l&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;net&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Listen&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;unix&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;types&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ReconfigureDomainSocket&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;

    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#000&#34;&gt;uc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ul&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;AcceptUnix&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;
        &lt;span style=&#34;color:#000&#34;&gt;_&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;uc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Write&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;([]&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;byte&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;})&lt;/span&gt;
        &lt;span style=&#34;color:#000&#34;&gt;reconfigure&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;触发平滑升级流程的两种方式最终都是启动一个新的 MOSN 进程，然后调用&lt;code&gt;GetInheritListeners()&lt;/code&gt;，通过 &lt;code&gt;isReconfigure()&lt;/code&gt; 函数来判断本机是否存在一个老的 MOSN（就是判断是否存在 &lt;code&gt;reconfig.sock&lt;/code&gt; 监听），如果存在一个老的 MOSN，就进入迁移流程，反之就是正常的启动流程。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// 保留了核心流程
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;GetInheritListeners&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;([]&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;net&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Listener&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;net&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Conn&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;error&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;isReconfigure&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#000&#34;&gt;l&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;net&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Listen&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;unix&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;types&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;TransferListenDomainSocket&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;uc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ul&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;AcceptUnix&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;_&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;oobn&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;_&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;_&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;uc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ReadMsgUnix&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;buf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;oob&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;file&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;os&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;NewFile&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;fd&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;fileListener&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;net&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;FileListener&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;file&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;listeners&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;uc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果进入迁移流程，新的 MOSN 将监听一个新的 Domain Socket（&lt;code&gt;listen.sock&lt;/code&gt;），用于老的 MOSN 传递 listen FD 到新的 MOSN。FD 的传递使用了sendMsg 和 recvMsg。在收到 listen FD 之后，调用 &lt;code&gt;net.FileListener()&lt;/code&gt; 函数生产一个 Listener。此时，新老 MOSN 都同时拥有了相同的 Listen 套接字。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// FileListener returns a copy of the network listener corresponding
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// to the open file f.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// It is the caller&amp;#39;s responsibility to close ln when finished.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Closing ln does not affect f, and closing f does not affect ln.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;FileListener&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;f&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;os&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;File&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ln&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Listener&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;error&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;ln&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;fileListener&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;OpError&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Op&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;file&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Net&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;file+net&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Source&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Addr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;fileAddr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Name&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()),&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Err&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的迁移和 Nginx 还是有一些区别，Nginx 是 fork 的方式，子进程自动就继承了 listen FD，MOSN 是新启动的进程，不存在父子关系，所以需要通过 sendMsg 的方式来传递。&lt;/p&gt;
&lt;p&gt;在进入迁移流程和 Listen 的迁移过程中，一共使用了两个 Domain Socket：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;reconfig.sock&lt;/code&gt; 是 Old MOSN 监听，用于 New MOSN 来判断是否存在&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listen.sock&lt;/code&gt; 是 New MOSN 监听，用于 Old MOSN 传递 listen FD&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个 sock 其实是可以复用的，也可以用 &lt;code&gt;reconfig.sock&lt;/code&gt; 进行 listen 的传递，由于一些历史原因搞了两个，后续可以优化为一个，让代码更精简易读。&lt;/p&gt;
&lt;p&gt;这儿再看看 Old MOSN 的处理，在收到 New MOSN 的通知之后，将进入&lt;code&gt;reconfigure(false)&lt;/code&gt; 流程，首先就是调用 &lt;code&gt;sendInheritListeners()&lt;/code&gt; 传递 listen FD，原因上面内容已经描述，最后调用 &lt;code&gt;WaitConnectionsDone()&lt;/code&gt; 进入存量长链接的迁移流程。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// 保留了核心流程
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;reconfigure&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;start&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;start&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#000&#34;&gt;startNewMosn&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;
        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// transfer listen fd
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;notify&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sendInheritListeners&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;();&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Wait for all connections to be finished
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;WaitConnectionsDone&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;GracefulTimeout&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;

    &lt;span style=&#34;color:#000&#34;&gt;os&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Exit&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 Listen FD 迁移之后，New MOSN 通过配置启动，然后在最后启动一个协程运行&lt;code&gt;TransferServer()&lt;/code&gt;，将监听一个新的 &lt;code&gt;DomainSocket（conn.sock）&lt;/code&gt;，用于后续接收 Old MOSN 的长连接迁移。迁移的函数是 &lt;code&gt;transferHandler()&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;TransferServer&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;handler&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;types&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ConnectionHandler&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;l&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;net&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Listen&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;unix&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;types&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;TransferConnDomainSocket&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;

    &lt;span style=&#34;color:#000&#34;&gt;utils&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;GoWithRecover&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;func&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;l&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Accept&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;
            &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferHandler&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;handler&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;transferMap&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;

        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;},&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Old MOSN 将通过 &lt;code&gt;transferRead()&lt;/code&gt; 和 &lt;code&gt;transferWrite()&lt;/code&gt; 进入最后的长链接迁移流程，下面主要分析这块内容。&lt;/p&gt;
&lt;h3 id=&#34;长连接迁移流程&#34;&gt;长连接迁移流程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;long-connection-migrating-process.png&#34; alt=&#34;长连接迁移过程&#34;&gt;&lt;/p&gt;
&lt;p&gt;首先先粗略看一下新请求的迁移流程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Client 发送请求到 MOSN&lt;/li&gt;
&lt;li&gt;MOSN 通过 domain  socket(conn.sock) 把 TCP1 的 FD 和连接的状态数据发送给 New MOSN&lt;/li&gt;
&lt;li&gt;New  MOSN 接受 FD 和请求数据创建新的 Conection 结构，然后把 Connection id 传给 MOSN，New MOSN 此时就拥有了 TCP1 的一个拷贝。&lt;/li&gt;
&lt;li&gt;New  MOSN 通过 LB 选取一个新的 Server，建立 TCP3 连接，转发请求到 Server&lt;/li&gt;
&lt;li&gt;Server 回复响应到 New MOSN&lt;/li&gt;
&lt;li&gt;New MOSN 通过 MOSN 传递来的 TCP1 的拷贝，回复响应到 Client&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前的 &lt;code&gt;WaitConnectionsDone()&lt;/code&gt; 函数中，&lt;code&gt;s.stopChan&lt;/code&gt; 已经关闭，在链接的 ReadLoop 中，将设置一个 &lt;code&gt;[TransferTimeout, 2 * TransferTimeout]&lt;/code&gt; 的随机时间进入迁移流程，随机数主要是为了打散每个 Client 的 TCP 连接迁移时机，让迁移更平滑。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;connection&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;startReadLoop&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferTime&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;time&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Time&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;stopChan&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;
            &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferTime&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;IsZero&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;transferCallbacks&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;transferCallbacks&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
                    &lt;span style=&#34;color:#000&#34;&gt;randTime&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;time&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Duration&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;rand&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Intn&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;TransferTimeout&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Nanoseconds&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;())))&lt;/span&gt;
                    &lt;span style=&#34;color:#000&#34;&gt;transferTime&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;time&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Now&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;TransferTimeout&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;randTime&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
                    &lt;span style=&#34;color:#000&#34;&gt;log&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DefaultLogger&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Infof&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;[network] [read loop] transferTime: Wait %d Second&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;TransferTimeout&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;randTime&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1e9&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
                &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
                    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// set a long time, not transfer connection, wait mosn exit.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;                    &lt;span style=&#34;color:#000&#34;&gt;transferTime&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;time&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Now&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;TransferTimeout&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
                    &lt;span style=&#34;color:#000&#34;&gt;log&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DefaultLogger&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Infof&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;[network] [read loop] not support transfer connection, Connection = %d, Local Address = %+v, Remote Address = %+v&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
                        &lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;rawConnection&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;LocalAddr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(),&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;RemoteAddr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;())&lt;/span&gt;
                &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferTime&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Before&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;time&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Now&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;())&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
                    &lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;transfer&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;
                    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt;
                &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在等待一个随机时间之后，&lt;code&gt;c.tranfer()&lt;/code&gt; 将进入迁移流程，&lt;code&gt;c.notifyTransfer()&lt;/code&gt; 的作用是暂停 write 操作，在迁移 read 操作的时候，不能有 write 操作，因为两个进程 MOSN 同时都做 write，会导致数据错乱。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;connection&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transfer&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;notifyTransfer&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferRead&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;transferWrite&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后进入的是 &lt;code&gt;transferRead()&lt;/code&gt;，这个函数的作用就是把连接的 FD 和状态数据通过 &lt;code&gt;conn.sock&lt;/code&gt;传递给 New MOSN，跟之前迁移 Listen FD 时方式一样，NEW MOSN 在成功处理之后会返回一个 ID，这个 ID 是 NEW MOSN 新建立的 Connection ID，这个 ID 后面会用到。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// old mosn transfer readloop
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferRead&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;connection&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;uint64&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;error&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;unixConn&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;net&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Dial&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;unix&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;types&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;TransferConnDomainSocket&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;

    &lt;span style=&#34;color:#000&#34;&gt;file&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;tlsConn&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferGetFile&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;

    &lt;span style=&#34;color:#000&#34;&gt;uc&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;unixConn&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;net&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;UnixConn&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    
    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// send type and TCP FD
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferSendType&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;uc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;file&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    
    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// send header + buffer + TLS
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferReadSendData&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;uc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;tlsConn&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;readBuffer&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;log&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DefaultLogger&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    
    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// recv ID
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;id&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferRecvID&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;uc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们构造了一个简单的读迁移协议, 主要包括了 TCP 原始数据长度，TLS 数据长度，TCP 原始数据，TLS 数据。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;/**&lt;/span&gt;
 &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;transfer&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;read&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;protocol&lt;/span&gt;
 &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;header&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;bytes&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;readBuffer&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;TLS&lt;/span&gt;
 &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;
 &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;                       &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;4&lt;/span&gt;                       &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;8&lt;/span&gt;
 &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+-----+-----+-----+-----+-----+-----+-----+-----+&lt;/span&gt;
 &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;|&lt;/span&gt;      &lt;span style=&#34;color:#000&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;length&lt;/span&gt;      &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;|&lt;/span&gt;     &lt;span style=&#34;color:#000&#34;&gt;TLS&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;length&lt;/span&gt;        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;|&lt;/span&gt;
 &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+-----+-----+-----+-----+-----+-----+-----+-----+&lt;/span&gt;
 &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;|&lt;/span&gt;                     &lt;span style=&#34;color:#000&#34;&gt;data&lt;/span&gt;                      &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;|&lt;/span&gt;
 &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+-----+-----+-----+-----+-----+-----+-----+-----+&lt;/span&gt;
 &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;|&lt;/span&gt;                     &lt;span style=&#34;color:#000&#34;&gt;TLS&lt;/span&gt;                       &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;|&lt;/span&gt;
 &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+-----+-----+-----+-----+-----+-----+-----+-----+&lt;/span&gt;
 &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在看下 New MOSN 收到迁移请求之后的处理，它会针对每个迁移请求会启动一个协程运行 &lt;code&gt;transferHandler()&lt;/code&gt; 函数, 函数会根据读取的协议判断是读迁移还是写迁移，我们这儿先介绍读迁移，New MOSN 会调用 transferNewConn 把 Old MOSN 传递过来的 FD 和数据包重新生成一个新的 Connection 结构体，并把生成的新的 connection ID 传递给 Old MOSN。&lt;/p&gt;
&lt;p&gt;此后，New MOSN 将从该 TCP 连接读取数据，开始正常的业务请求流程。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferHandler&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;net&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Conn&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;handler&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;types&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ConnectionHandler&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferMap&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;sync&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Map&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// recv type
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;conn&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferRecvType&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;uc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#000&#34;&gt;log&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DefaultLogger&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Errorf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;[network] [transfer] [handler] transferRecvType error :%v&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;conn&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// transfer read
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// recv header + buffer
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#000&#34;&gt;dataBuf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;tlsBuf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferReadRecvData&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;uc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#000&#34;&gt;log&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DefaultLogger&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Errorf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;[network] [transfer] [handler] transferRecvData error :%v&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
            &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#000&#34;&gt;connection&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferNewConn&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;conn&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;dataBuf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;tlsBuf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;handler&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferMap&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;connection&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#000&#34;&gt;transferSendID&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;uc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;connection&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#000&#34;&gt;transferSendID&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;uc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferErr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// transfer write
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// recv header + buffer
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#000&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;buf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferWriteRecvData&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;uc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#000&#34;&gt;log&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DefaultLogger&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Errorf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;[network] [transfer] [handler] transferRecvData error :%v&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#000&#34;&gt;connection&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferFindConnection&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;transferMap&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87&#34;&gt;uint64&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;
        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;connection&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#000&#34;&gt;log&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DefaultLogger&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Errorf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;[network] [transfer] [handler] transferFindConnection failed, id = %d&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
            &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferWriteBuffer&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;connection&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;buf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#000&#34;&gt;log&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DefaultLogger&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Errorf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;[network] [transfer] [handler] transferWriteBuffer error :%v&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
            &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此后，Old MOSN 不再读取该 TCP1 连接上的数据，全部由 New MOSN 来读取 TCP1 上的数据并处理，对于新的请求，整个迁移过程就已经完成。&lt;/p&gt;
&lt;h3 id=&#34;残留响应迁移流程&#34;&gt;残留响应迁移流程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;remaining-responses-migrating-process.png&#34; alt=&#34;残留响应迁移过程&#34;&gt;&lt;/p&gt;
&lt;p&gt;大家想想为什么还有残留响应的迁移流程？因为多路复用协议，在之前读连接迁移流程的时候，TCP2 上还有之前残留的响应需要回复给Client，如果同时 MOSN 和 New MOSN 都进行 Write 操作 TCP1，数据可能会乱序，所以需要让New MOSN来统一处理之前 TCP2 上残留的响应。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Server 回复残留的响应到 MOSN&lt;/li&gt;
&lt;li&gt;MOSN 把之前从 New MOSN 获取的 Connection id 和响应数据，通过 domain socket(conn.sock) 传递给 New MOSN&lt;/li&gt;
&lt;li&gt;New MOSN 通过 id 查询 TCP1 连接，回复响应到 Client&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 &lt;code&gt;transferRead()&lt;/code&gt; 之后，就进入了 &lt;code&gt;transferWrite()&lt;/code&gt; 阶段，该阶段会把需要 write 的数据包和之前 New MOSN 传回来的 Connection ID 一并传给 New MOSN。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// old mosn transfer writeloop
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferWrite&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;connection&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;id&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;uint64&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;error&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#000&#34;&gt;unixConn&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;net&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Dial&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;unix&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;types&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;TransferConnDomainSocket&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;

    &lt;span style=&#34;color:#000&#34;&gt;uc&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;unixConn&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;net&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;UnixConn&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferSendType&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;uc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;

    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// build net.Buffers to IoBuffer
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;buf&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferBuildIoBuffer&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// send header + buffer
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;transferWriteSendData&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;uc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;),&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;buf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#000&#34;&gt;log&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DefaultLogger&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Errorf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;[network] [transfer] [write] transferWrite failed: %v&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们构造了一个简单的写迁移协议, 主要包括了TCP原始数据长度, connection ID，TCP原始数据。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt; *  transfer write protocol
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt; *  header (8 bytes) + (writeBuffer data)
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt; *
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt; * 0                       4                       8
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt; * +-----+-----+-----+-----+-----+-----+-----+-----+
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt; * |      data length      |    connection  ID     |
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt; * +-----+-----+-----+-----+-----+-----+-----+-----+
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt; * |                     data                      |
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt; * +-----+-----+-----+-----+-----+-----+-----+-----+
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt; *
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;**/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在New MOSN的transferHandler()函数中，会判断出写迁移协议，然后 &lt;code&gt;transferFindConnection()&lt;/code&gt; 函数通过 connection ID 找到 TCP1 连接，然后直接把数据写入即可。&lt;/p&gt;
&lt;p&gt;这儿需要说明一点，新请求Request的转发已经使用了 TCP3，TCP2 上只会有之前请求的 Response 响应，如果在整个迁移期间 2 * TransferTimeout 都没有回复响应，那么这个请求将会超时失败。&lt;/p&gt;
&lt;h3 id=&#34;连接状态数据&#34;&gt;连接状态数据&lt;/h3&gt;
&lt;p&gt;在连接迁移时，除了TCP FD的迁移，还有连接状态的迁移，这样New MOSN才知道怎样去初始化这个新的连接。&lt;/p&gt;
&lt;p&gt;主要有如下几个状态：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示在迁移时，已经从 TCP 读取的数据，还没有被应用层处理的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在迁移之后，MOSN 收到的响应数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TLS状态迁移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果是 TLS 加密请求，需要迁移 TLS 的状态，有如下状态需要迁移：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加密秘钥&lt;/li&gt;
&lt;li&gt;Seq序列&lt;/li&gt;
&lt;li&gt;读缓存数据（加密和未加密）&lt;/li&gt;
&lt;li&gt;cipher类型&lt;/li&gt;
&lt;li&gt;TLS版本&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;TransferTLSInfo&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;Vers&lt;/span&gt;         &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;uint16&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;CipherSuite&lt;/span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;uint16&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;MasterSecret&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;byte&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;ClientRandom&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;byte&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;ServerRandom&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;byte&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;InSeq&lt;/span&gt;        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;byte&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;OutSeq&lt;/span&gt;       &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;byte&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;RawInput&lt;/span&gt;     &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;byte&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;Input&lt;/span&gt;        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;byte&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;长连接的 FD 迁移是比较常规的操作，sendMsg 和 connection repair 都可以。&lt;/p&gt;
&lt;p&gt;在整个过程中最麻烦的是应用层数据的迁移，一般想法就是把应用层的数据结构等都迁移到新的进程，比如已经读取的协议 HEAD 等结构体，但这就导致你的迁移过程会很复杂，每个协议都需要单独处理。&lt;/p&gt;
&lt;p&gt;MOSN 的方案是把迁移放到了 IO 层，不关心应用层具体是什么协议，我们迁移最原始的 TCP 数据包，然后让 New MOSN 来 codec 这个数据包来拼装 HEAD 等结构体，这个过程是标准的处理流程了，这样就保证迁移对整个协议解析是透明的，只要这个协议是无状态的，这个迁移框架就可以自动支持。&lt;/p&gt;
&lt;p&gt;最后的残留响应迁移流程可能不太好理解，为什么不等所有响应完成之后才开始迁移，就不需要这个流程了？是因为在多路复用协议场景下，请求一直在发送，你不能总是找到一个时间点所有响应都完成了。&lt;/p&gt;
&lt;h2 id=&#34;反馈&#34;&gt;反馈&lt;/h2&gt;
&lt;p&gt;关于该问题的讨论请见 Github Issue：&lt;a href=&#34;https://github.com/mosn/mosn/issues/866&#34;&gt;MOSN smooth upgrade problem #866&lt;/a&gt;。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: MOSN 多协议机制解析</title>
      <link>https://brpc.incubator.apache.org/docs/concept/multi-protocol/</link>
      <pubDate>Wed, 01 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/concept/multi-protocol/</guid>
      <description>
        
        
        &lt;p&gt;我们将按以下顺序进行介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多协议机制产生的背景与实践痛点；&lt;/li&gt;
&lt;li&gt;常见的协议扩展思路初探；&lt;/li&gt;
&lt;li&gt;SOFABolt 协议接入实践；&lt;/li&gt;
&lt;li&gt;MOSN 多协议机制设计解读；&lt;/li&gt;
&lt;li&gt;后续规划及展望；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中第三点「接入实践」是今天分享的重点，希望能给大家就「如何在 MOSN 中快速扩展私有协议接入」有一个具体的感受。另外「MOSN 如何实现多协议框架」也是很多人关心和问题，我们将摘选几个技术功能，对其背后的设计思考进行解读。&lt;/p&gt;
&lt;h2 id=&#34;多协议机制产生的背景与实践痛点&#34;&gt;多协议机制产生的背景与实践痛点&lt;/h2&gt;
&lt;p&gt;首先介绍一下多协议机制产生的背景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1585209248463-b8b38ab0-09ed-4225-8d60-5bad3c2a372b.png&#34; alt=&#34;多协议机制&#34;&gt;&lt;/p&gt;
&lt;p&gt;前面提到，蚂蚁集团 2019 年双十一核心链路百分之百 Mesh 化，是业界当时已知的最大规模的 Service Mesh 落地，为什么我们敢这么做？因为我们具备能够让架构平滑迁移的方案。&amp;ldquo;兼容性&amp;quot;是任何架构演进升级都必然要面对的一个问题，这在早已实践微服务化架构的蚂蚁集团内部同样如此。为了实现架构的平滑迁移，需要让新老节点的外在行为尽可能的表现一致，从而让依赖方无感知，这其中很重要的一点就是保持协议兼容性。&lt;/p&gt;
&lt;p&gt;因此，我们需要在 Service Mesh 架构下，兼容现有微服务体系中的通信协议——也就是说需要在 MOSN 内实现对目前蚂蚁集团内部通信协议的扩展支持。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1585209248513-3bf90371-3d7c-4a0f-a98a-db4538bb2271.png&#34; alt=&#34;协议扩展支持&#34;&gt;&lt;/p&gt;
&lt;p&gt;基于 MOSN 本身的扩展机制，我们完成了最初版本的协议扩展接入。但是在实践过程中，我们发现这并不是一件容易的事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相比编解码，协议自身的处理以及与框架集成才是其中最困难的环节，需要理解并实现包括请求生命周期、多路复用处理、链接池等等机制；&lt;/li&gt;
&lt;li&gt;社区主流的 xDS 路由配置是面向 HTTP 协议的，无法直接支持私有协议，存在适配成本；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于这些实践痛点，我们设计了 MOSN 多协议框架，希望可以降低私有协议的接入成本，加快普及 ServiceMesh 架构的落地推进。&lt;/p&gt;
&lt;h2 id=&#34;常见的协议扩展思路初探&#34;&gt;常见的协议扩展思路初探&lt;/h2&gt;
&lt;p&gt;前面介绍了背景，那么具体协议扩展框架要怎么设计呢？我们先来看一下业界的思路与做法。&lt;/p&gt;
&lt;h3 id=&#34;协议扩展框架---envoy&#34;&gt;协议扩展框架 - Envoy&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;1585209248576-01797bba-8a94-4960-be17-1c87c725a75a.png&#34; alt=&#34;Envoy 的协议扩展&#34;&gt;&lt;/p&gt;
&lt;p&gt;注：图片来自 Envoy 分享资料&lt;/p&gt;
&lt;p&gt;第一个要介绍的是目前发展势头强劲的 Envoy。从图上可以看出，Envoy 支持四层的读写过滤器扩展、基于 HTTP 的七层读写过滤器扩展以及对应的 Router/Upstream 实现。如果想要基于 Envoy 的扩展框架实现 L7 协议接入，目前的普遍做法是基于 L4 filter 封装相应的 L7 codec，在此基础之上再实现对应的协议路由等能力，无法复用 HTTP L7 的扩展框架。&lt;/p&gt;
&lt;h3 id=&#34;协议扩展框架---nginx&#34;&gt;协议扩展框架 - Nginx&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;1585209248600-c47725ed-7d47-4c07-ad1b-f2e2ba4ea2c6.png&#34; alt=&#34;Nginx 的协议扩展&#34;&gt;&lt;/p&gt;
&lt;p&gt;第二个则是老牌的反向代理软件 Nginx，其核心模块是基于 Epoll/Kqueue 等 I/O 多路复用技术之上的离散事件框架，基于事件框架之上构建了 Mail、Http 等协议模块。与 Envoy 类似，如果要基于 Nginx 扩展私有协议，那么也需要自行对接事件框架，并完整实现包括编解码、协议处理等能力。&lt;/p&gt;
&lt;h3 id=&#34;协议扩展框架---mosn&#34;&gt;协议扩展框架 - MOSN&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;1585209248645-5d6eac2f-962e-4c3c-92f1-814d18db47cd.png&#34; alt=&#34;MOSN 的协议扩展框架&#34;&gt;&lt;/p&gt;
&lt;p&gt;最后回过头来，我们看一下 MOSN 是怎么做的。实际上，MOSN 的底层机制与 Envoy、Nginx 并没有核心差异，同样支持基于 I/O 多路复用的 L4 读写过滤器扩展，并在此基础之上再封装 L7 的处理。但是与前两者不同的是，MOSN 针对典型的微服务通信场景，抽象出了一套适用于基于多路复用 RPC 协议的扩展框架，屏蔽了 MOSN 内部复杂的协议处理及框架流程，开发者只需要关注协议本身，并实现对应的框架接口能力即可实现快速接入扩展。&lt;/p&gt;
&lt;h3 id=&#34;三种框架成本对比&#34;&gt;三种框架成本对比&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;1585209248614-5807d3b3-fb18-4a15-83ef-e05bb162f222.png&#34; alt=&#34;三种框架成本对比&#34;&gt;&lt;/p&gt;
&lt;p&gt;最后对比一下，典型微服务通信框架协议接入的成本，由于 MOSN 针对此类场景进行了框架层面的封装支持，因此可以节省开发者大量的研发成本。&lt;/p&gt;
&lt;h2 id=&#34;sofabolt-协议接入实践&#34;&gt;SOFABolt 协议接入实践&lt;/h2&gt;
&lt;p&gt;初步了解多协议框架的设计思路之后，让我们以 SOFABolt 协议为例来实际体验一下协议接入的过程。&lt;/p&gt;
&lt;h3 id=&#34;sofabolt-简介&#34;&gt;SOFABolt 简介&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;1585209248663-0e25c95b-d711-4de2-9a42-f71d05b360df.png&#34; alt=&#34;SOFABolt 简介&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里先对 SOFABolt 进行一个简单介绍，SOFABolt 是一个开源的轻量、易用、高性能、易扩展的  RPC 通信框架，广泛应用于蚂蚁集团内部。&lt;/p&gt;
&lt;p&gt;SOFABolt：&lt;a href=&#34;https://github.com/sofastack/sofa-bolt&#34;&gt;https://github.com/sofastack/sofa-bolt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基于 MOSN 的多协议框架，实际编写了 7 个代码文件，一共 925 行代码(包括 liscence、comment 在内)就完成了接入。如果对于协议本身较为熟悉，且具备一定的 MOSN/Golang 开发经验，甚至可以在一天内就完成整个协议的扩展，可以说接入成本是非常之低。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1585209248669-1138c7d3-fc69-446c-99a9-65932aebca99.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Github:
&lt;a href=&#34;https://github.com/mosn/mosn/tree/master/pkg/protocol/xprotocol/bolt&#34;&gt;https://github.com/mosn/mosn/tree/master/pkg/protocol/xprotocol/bolt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面让我们进入正题，一步一步了解接入过程。&lt;/p&gt;
&lt;h3 id=&#34;step1确认协议格式&#34;&gt;Step1：确认协议格式&lt;/h3&gt;
&lt;p&gt;第一步，需要确认要接入的协议格式。为什么首先要做这个，因为协议格式是一个协议最基本的部分，有以下两个层面的考虑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任何协议特性以及协议功能都能在上面得到一些体现，例如有无 requestId/streamId 就直接关联到协议是否支持连接多路复用；&lt;/li&gt;
&lt;li&gt;协议格式与报文模型直接相关，两者可以构成逻辑上的映射关系；而这个映射关系也就是所谓的编解码逻辑；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;1585209248674-536ba7de-4f23-4797-a3db-cc085ec8a620.png&#34; alt=&#34;确认协议格式&#34;&gt;&lt;/p&gt;
&lt;p&gt;以 SOFABolt 为例，其第一个字节是协议 magic，可以用于校验当前报文是否属于 SOFABolt 协议，并可以用于协议自动识别匹配的场景；第二个字节是 type，用于标识当前报文的传输类型，可以是 Request / RequestOneway / Response 中的一种；第三个字节则是当前报文的业务类型，可以是心跳帧，RPC 请求/响应等类型。后面的字段就不一一介绍了，可以发现， &lt;strong&gt;理解了协议格式本身，其实对于协议的特性支持和模型编解码就理解了一大半，&lt;/strong&gt; 因此第一步协议格式的确认了解是重中之重，是后续一切工作开展的前提。&lt;/p&gt;
&lt;h3 id=&#34;step2确认报文模型&#34;&gt;Step2：确认报文模型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;1585209248773-66c3234b-f805-4735-9e70-acf8abef294b.png&#34; alt=&#34;确认报文模型&#34;&gt;&lt;/p&gt;
&lt;p&gt;顺应第一步，第二步的主要工作是确认报文编程模型。一般地，在第一步完成之后，应当可以很顺利的构建出相应的报文模型，SOFABolt 例子中可以看出，模型字段设计基本与协议格式中的 header / payload 两部分相对应。有了编程模型之后，就可以继续进行下一步——基于模型实现对应的框架扩展了。&lt;/p&gt;
&lt;h3 id=&#34;step3接口实现---协议&#34;&gt;Step3：接口实现 - 协议&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;1585209248724-28eaa458-a928-4f19-bf16-96895808a5b8.png&#34; alt=&#34;接口实现-协议&#34;&gt;&lt;/p&gt;
&lt;p&gt;协议扩展，顾名思义，是指协议层面的扩展，描述的是协议自身的行为（区别于报文自身）。&lt;/p&gt;
&lt;p&gt;目前多协议框架提供的接口包括以下五个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Name：协议名称，需要具备唯一性；&lt;/li&gt;
&lt;li&gt;Encoder：编码器，用于实现从报文模型到协议传输字节流的映射转换；&lt;/li&gt;
&lt;li&gt;Decoder：解码器，用于实现从协议传输字节流到报文模型的映射转换；&lt;/li&gt;
&lt;li&gt;Heartbeater：心跳处理，用于实现心跳保活报文的构造，包括探测发起与回复两个场景；&lt;/li&gt;
&lt;li&gt;Hijacker：错误劫持，用于在特定错误场景下错误报文的构造；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;step4接口实现---报文&#34;&gt;Step4：接口实现 - 报文&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;1585209248793-9cb8efd3-c12e-4da1-91f9-0901bcf36e16.png&#34; alt=&#34;接口实现-报文&#34;&gt;&lt;/p&gt;
&lt;p&gt;前面介绍了协议扩展，接下里则是报文扩展，这里关注的是单个请求报文需要实现的行为。&lt;/p&gt;
&lt;p&gt;目前框架抽象的接口包括以下几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Basic：需要提供 GetStreamType、GetHeader、GetBody 几个基础方法，分别对应传输类型、头部信息、载荷信息；&lt;/li&gt;
&lt;li&gt;Multiplexing：多路复用能力，需要实现 GetRequestId 及 SetRequestId；&lt;/li&gt;
&lt;li&gt;HeartbeatPredicate：用于判断当前报文是否为心跳帧；&lt;/li&gt;
&lt;li&gt;GoAwayPredicate：用于判断当前报文是否为优雅退出帧；&lt;/li&gt;
&lt;li&gt;ServiceAware：用于从报文中获取 service、method 等服务信息；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;举个例子&#34;&gt;举个例子&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;1585209248756-4c3fce60-436b-4153-9372-b39fe80fc975.png&#34; alt=&#34;案例&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里举一个例子，来让大家对&lt;strong&gt;框架如何基于接口封装处理流程&lt;/strong&gt;有一个体感：服务端心跳处理场景。当框架收到一个报文之后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据报文扩展中的 GetStreamType 来确定当前报文是请求还是响应。如果是请求则继续 2；&lt;/li&gt;
&lt;li&gt;根据报文扩展中的 HeartbeatPredicate 来判断当前报文是否为心跳包，如果是则继续 3；&lt;/li&gt;
&lt;li&gt;当前报文是心跳探测(request + heartbeat)，需要回复心跳响应，此时根据协议扩展中的 Heartbeater.Reply 方法构造对应的心跳响应报文；&lt;/li&gt;
&lt;li&gt;再根据协议扩展的 Encoder 实现，将心跳响应报文转换为传输字节流；&lt;/li&gt;
&lt;li&gt;最后调用 MOSN 网络层接口，将传输字节流回复给发起心跳探测的客户端；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当协议扩展与报文扩展都实现之后，MOSN 协议扩展接入也就完成了，框架可以依据协议扩展的实现来完成协议的处理，让我们实际演示一下 SOFABolt 接入的 example。&lt;/p&gt;
&lt;p&gt;Demo 地址：&lt;a href=&#34;https://github.com/mosn/mosn/tree/master/examples/codes/sofarpc-with-xprotocol-sample&#34;&gt;https://github.com/mosn/mosn/tree/master/examples/codes/sofarpc-with-xprotocol-sample&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;mosn-多协议机制设计解读&#34;&gt;MOSN 多协议机制设计解读&lt;/h2&gt;
&lt;p&gt;通过 SOFABolt 协议接入的实践过程，大家对如何基于 MOSN 来做协议扩展应该有了一个初步的认知。那么 MOSN 多协议机制究竟封装了哪些逻辑，背后又是如何思考设计的？接下来将会挑选几个典型技术案例为大家进行解读。&lt;/p&gt;
&lt;h3 id=&#34;协议扩展框架&#34;&gt;协议扩展框架&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;协议扩展框架 -  编解码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1585227625966-1b00d83d-fff1-40f1-b6b1-3bda19db0afb.png&#34; alt=&#34;协议扩展框架-编解码&#34;&gt;&lt;/p&gt;
&lt;p&gt;最先介绍的是编解码机制，这个在前面 SOFABolt 接入实践中已经简单介绍过，MOSN 定义了编码器及解码器接口来屏蔽不同协议的编解码细节。协议接入时只需要实现编解码接口，而不用关心相应的接口调用上下文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;协议扩展框架 - 多路复用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1585209248762-c83706cd-b413-468c-80b1-151de9ae8f3c.png&#34; alt=&#34;协议扩展看框架-多路复用&#34;&gt;&lt;/p&gt;
&lt;p&gt;接下来是多路复用机制的解读，这也是流程中相对不太好理解的一部分。首先明确一下链接多路复用的定义：允许在单条链接上，并发处理多个请求/响应。那么支持多路复用有什么好处呢？&lt;/p&gt;
&lt;p&gt;以 HTTP 协议演进为例，HTTP/1 虽然可以维持长连接，但是单条链接同一时间只能处理一个请求/相应，这意味着如果同时收到了 4 个请求，那么需要建立四条 TCP 链接，而建链的成本相对来说比较高昂；HTTP/2 引入了 stream/frame 的概念，支持了分帧多路复用能力，在逻辑上可以区分出成对的请求 stream 和响应 stream，从而可以在单条链接上并发处理多个请求/响应，解决了 HTTP/1 链接数与并发数成正比的问题。&lt;/p&gt;
&lt;p&gt;类似的，典型的微服务框架通信协议，如 Dubbo、SOFABolt 等一般也都实现了链接多路复用能力，因此 MOSN 封装了相应的多路复用处理流程，来简化协议接入的成本。让我们跟随一个请求代理的过程，来进一步了解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1585209248791-900751cb-c096-48d4-a5d5-d8247ef9d725.png&#34; alt=&#34;上下游关联映射&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MOSN 从 downstream(conn=2) 接收了一个请求 request，依据报文扩展多路复用接口 GetRequestId 获取到请求在这条连接上的身份标识(requestId=1)，并记录到关联映射中待用；&lt;/li&gt;
&lt;li&gt;请求经过 MOSN 的路由、负载均衡处理，选择了一个 upstream(conn=5)，同时在这条链接上新建了一个请求流(requestId=30)，并调用文扩展多路复用接口 SetRequestId 封装新的身份标识，并记录到关联映射中与 downstream 信息组合；&lt;/li&gt;
&lt;li&gt;MOSN 从 upstream(conn=5) 接收了一个响应 response，依据报文扩展多路复用接口 GetRequestId 获取到请求在这条连接上的身份标识(requestId=30)。此时可以从上下游关联映射表中，根据 upstream 信息(connId=5, requestId=30) 找到对应的 downstream 信息(connId=2, requestId=1)；&lt;/li&gt;
&lt;li&gt;依据 downstream request 的信息，调用文扩展多路复用接口 SetRequestId 设置响应的 requestId，并回复给 downstream；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在整个过程中，框架流程依赖的报文扩展 Multiplexing 接口提供的能力，实现了上下游请求的多路复用关联处理，除此之外，框架还封装了很多细节的处理，例如上下游复用内存块合并处理等等，此处限于篇幅不再展开，有兴趣的同学可以参考源码进行阅读。&lt;/p&gt;
&lt;h3 id=&#34;统一路由框架&#34;&gt;统一路由框架&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;1585209248786-ff9c157a-5ff9-444b-8b0f-2da90ddb8392.png&#34; alt=&#34;统一路由框架&#34;&gt;&lt;/p&gt;
&lt;p&gt;接下来要分析的是「统一路由框架」的设计，此方案主要解决的是非 HTTP 协议的路由适配问题。我们选取了以下三点进行具体分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过基于属性匹配(attribute-based)的模式，与具体协议字段解耦；&lt;/li&gt;
&lt;li&gt;引入层级路由的概念，解决属性扁平化后带来的线性匹配性能问题；&lt;/li&gt;
&lt;li&gt;通过变量机制懒加载的特定，按需实现深/浅解包；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;统一路由框架 – 基于属性匹配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1585209248809-fe944cba-e8df-4497-8eff-c8d47131c918.png&#34; alt=&#34;统一路由框架-基于属性匹配&#34;&gt;&lt;/p&gt;
&lt;p&gt;首先来看一下典型的 RDS 配置，可以看到其中的 domains、path 等字段，对应的是 HTTP 协议里的域名、路径概念，这就意味着其匹配条件只有 HTTP 协议才有字段能够满足，配置结构设计是与 HTTP 协议强相关的。这就导致了如果我们新增了一个私有协议，无法复用 RDS 的配置来做路由。&lt;/p&gt;
&lt;p&gt;那么如何解决配置模型与协议字段强耦合呢？简单来说就是把匹配字段拆分为扁平属性的键值对(key-value pair)，匹配策略基于键值对来处理，从而解除了匹配模型与协议字段的强耦合，例如可以配置 &lt;code&gt;key: $http_host&lt;/code&gt;，也可以配置 &lt;code&gt;key:$dubbo_service&lt;/code&gt;，这在配置模型层面都是合法的。&lt;/p&gt;
&lt;p&gt;但是这并不是说匹配就有具体协议无关了，这个关联仍然是存在的，只是从强耦合转换为了隐式关联，例如配置 &lt;code&gt;key: $http_host&lt;/code&gt;，从结构来说其与 HTTP 协议并无耦合，但是值变量仍然会通过 HTTP 协议字段来进行求值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;统一路由框架 -  层级路由&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1585209248832-20483dc3-e959-4cf4-aecd-cbe5ba37b4fb.png&#34; alt=&#34;统一路由框架 -  层级路由&#34;&gt;&lt;/p&gt;
&lt;p&gt;在引入「基于属性的匹配」之后，我们发现了一个问题，那就是由于属性本身的扁平化，其内在并不包含层级关系。如果没有层级关系，会导致匹配时需要遍历所有可能的情况组合，大量条件的场景下匹配性能近似于线性的 O(n)，这显然是无法接受的。&lt;/p&gt;
&lt;p&gt;举例来说，对于 HTTP 协议，我们总是习惯与以下的匹配步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;匹配 Host(:authority) ；&lt;/li&gt;
&lt;li&gt;匹配 Path ；&lt;/li&gt;
&lt;li&gt;匹配 headers/args/cookies ；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这其实构成了一个层级关系，每一层就像是一个索引，通过层级的索引关系，在大量匹配条件的情况下仍然可以获得一个可接受的耗时成本。但是对于属性(attribute)，多个属性之间并没有天然的层级关系(相比于 host、path 这种字段)，这依赖于属性背后所隐式关联的字段，例如对于 Dubbo 协议，我们希望的顺序可能是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;匹配 &lt;code&gt;$dubbo_service&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;匹配 &lt;code&gt;$dubbo_group&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;匹配 &lt;code&gt;$dubbo_version&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;匹配 &lt;code&gt;$dubbo_attachments_xx&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此在配置模型上，我们引入了对应的索引层级概念，用于适配不同协议的结构化层级路由，解决扁平属性的线性匹配性能问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;统一路由框架 - 浅解包优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1585209248848-77a91fc3-ab6c-4eb8-a62b-3496668d66c3.png&#34; alt=&#34;统一路由框架 - 浅解包优化&#34;&gt;&lt;/p&gt;
&lt;p&gt;最后，介绍一下浅解包优化的机制。利用 MOSN 变量懒加载的特性，我们可以在报文解析时，先不去解析成本较高的部分，例如 dubbo 协议的 attachments。那么在代理请求的实际过程中，需要使用到 attachments 里的信息时，就会通过变量的 getter 求值逻辑来进行真正的解包操作。依靠此特性，可以大幅优化在不需要深解包的场景下 dubbo 协议代理转发的性能表现，实现按需解包。&lt;/p&gt;
&lt;h3 id=&#34;解读总结&#34;&gt;解读总结&lt;/h3&gt;
&lt;p&gt;最后，对设计部分的几个技术案例简单总结一下，整体的思路仍然是对处理流程进行抽象封装，并剥离可扩展点，从而降低用户的接入成本。&lt;/p&gt;
&lt;p&gt;在协议扩展支持方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;封装编解码流程，抽象编解码能力接口作为协议扩展点&lt;/li&gt;
&lt;li&gt;封装协议处理流程，抽象多路复用、心跳保活、优雅退出等能力接口作为协议扩展点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在路由框架方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过改为基于属性匹配的机制，与具体协议字段解耦，支持多协议适配；&lt;/li&gt;
&lt;li&gt;引入层级路由机制，解决属性扁平化的匹配性能问题；&lt;/li&gt;
&lt;li&gt;利用变量机制懒加载特性，按需实现深/浅解包；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;后续规划及展望&#34;&gt;后续规划及展望&lt;/h2&gt;
&lt;h3 id=&#34;更多流模式支持更多协议接入&#34;&gt;更多流模式支持、更多协议接入&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;1585209248869-cc2b0d96-1e9c-4e77-8047-d2022dd3dac0.png&#34; alt=&#34;更多流模式支持、更多协议接入&#34;&gt;&lt;/p&gt;
&lt;p&gt;当前 MOSN 多协议机制，已经可以比较好的支持像 Dubbo、SOFABolt 这样基于多路复用流模型的微服务协议，后续会继续扩展支持的类型及协议，例如经典的 PING-PONG 协议、Streaming 流式协议，也欢迎大家一起参与社区建设，贡献你的 PR。&lt;/p&gt;
&lt;h3 id=&#34;社区标准方案推进&#34;&gt;社区标准方案推进&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;1585209248892-b736ba21-4a23-4f8b-9ba0-7623f7125e72.png&#34; alt=&#34;社区标准方案推进&#34;&gt;&lt;/p&gt;
&lt;p&gt;与此同时，我们注意到 Istio 社区其实也有类似的需求，希望设计一套协议无关的路由机制——&amp;ldquo;Istio Meta Routing API&amp;rdquo;。其核心思路与 MOSN 的多协议路由框架基本一致，即通过基于属性的路由来替代基于协议字段的路由。目前该草案还处于一个比较初级的阶段，对于匹配性能、字段扩展方面还没有比较完善的设计说明，后续 MOSN 团队会积极参与社区方案的讨论，进一步推动社区标准方案的落地。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: MOSN 扩展机制解析</title>
      <link>https://brpc.incubator.apache.org/docs/concept/extensions/</link>
      <pubDate>Thu, 09 Apr 2020 21:00:00 +0800</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/concept/extensions/</guid>
      <description>
        
        
        &lt;p&gt;本文将从以下几个方面介绍 MOSN 的扩展机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MOSN 扩展能力和扩展机制的详细介绍；&lt;/li&gt;
&lt;li&gt;结合示例对 MOSN 的 Filter 扩展机制与插件扩展机制进行详细介绍；&lt;/li&gt;
&lt;li&gt;MOSN 后续扩展能力规划与展望；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文中的示例在 MOSN 的 Github 的 &lt;code&gt;examples/codes/mosn-extensions&lt;/code&gt; 目录下，大家也可以下载下来运行一下。&lt;/p&gt;
&lt;h3 id=&#34;mosn-简介&#34;&gt;MOSN 简介&lt;/h3&gt;
&lt;p&gt;MOSN 作为云原生的网络代理，旨在为服务提供多协议、模块化、智能化、安全的代理能力。在实际生产使用中，不同的厂商会有不同的使用场景，通用的网络代理能力面对具体的业务场景会显得有些不足，通常都需要进行二次开发以满足业务需求。MOSN 在核心框架中，提供了一系列的扩展机制和扩展点，就是为了满足需要基于业务进行二次开发的场景，同时 MOSN 提供的部分通用逻辑也是基于扩展机制和扩展点的实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1586436268765-2c1afc84-0142-4217-b666-0cc9cbdf7e78.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;比如通过 MOSN “内置实现”的透明劫持的能力，就是通过 MOSN Filter 机制实现。而要实现消息的代理，则可以通过类似的扩展实现。在通用代理的情况下，可以通过 Filter 机制实现业务的认证鉴权，也可以实现定制的负载均衡逻辑；除了转发流程可以扩展实现以外，MOSN 还可以扩展日志的实现，用于对标已有的日志系统，也可以扩展 XDS 实现定制的配置更新；根据不同的业务场景还会有很多具体的扩展情况，就不在此展开了，有兴趣的可以关注 MOSN 社区正在建设的源代码分析系列文章与文档。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1586436269068-a0a77749-1a98-4bce-9e9b-323ea3bd14a5.png&#34; alt=&#34;图片 1.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;MOSN 作为一款网络代理，在转发链路上的网络层、协议层、转发层，在非转发链路上的配置、日志、Admin API 等都提供了扩展能力，对于协议扩展的部分，有兴趣的可以看一下上期直播讲的 &lt;a href=&#34;../multi-protocol&#34;&gt;MOSN 多协议机制解析&lt;/a&gt;，我们今天将重点介绍一下转发层的 Stream Filter 扩展机制与 MOSN 的插件机制。&lt;/p&gt;
&lt;h3 id=&#34;stream-filter-机制&#34;&gt;Stream Filter 机制&lt;/h3&gt;
&lt;p&gt;在实际业务场景中，在转发请求之前或者回写响应之前，都可能需要对请求/响应做一些处理，如判断是否需要进行转发的认证/鉴权，是否需要限流，又或者需要对请求/响应做一些具有业务语义的记录，需要对协议进行转换等。这些场景都与具体的业务高度耦合，是一个典型的需要进行二次开发的情况。MOSN 的 Stream Filter 机制就是为了满足这样的扩展场景所设计的，它也成为目前 MOSN 扩展中使用频率最高的扩展点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1586436268982-8881e2b5-d3a7-443e-ac1f-90735b32f4e9.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;在目前的内置 MOSN 实现中，Stream Filter 机制暂时与内置的 network filter: proxy 是绑定的，后面我们也考虑将这部分能力进行抽象，让其他 network filter 也可以复用这部分能力。&lt;/p&gt;
&lt;p&gt;关于 Stream Filter，今天会为大家讲解两个部分的内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个 Stream Filter 包含哪些部分以及在 MOSN 中是如何工作的；&lt;/li&gt;
&lt;li&gt;通过一个 Demo 演示来加深对 Stream Filter 的实现与应用；&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;一个完整的-stream-filter&#34;&gt;一个完整的 Stream Filter&lt;/h4&gt;
&lt;p&gt;一个完整的 StreamFilter，包含三个部分的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个 StreamFilter 对象，存在于每一个请求/响应当中，在 MOSN 收到请求的时候发挥作用，我们称为 ReceiverFilter，在 MOSN 收到响应时发挥作用，我们称为 SenderFilter。一个 StreamFilter 可以是其中任意一种，也可以是两种都是；&lt;/li&gt;
&lt;li&gt;一个 StreamFilterFactory 对象，用于 MOSN 在每次收到请求时，生成 StreamFilter 对象。在 Listener 配置解析时，一个 StreamFilter 的配置会生成一个其对于的 StreamFilterFactory。同一个 StreamFilter 在不同的 Listener 下可能对应不同的 StreamFilterFactory，但是也有的特殊情况下，StreamFilterFactory 可能需要实现为单例；&lt;/li&gt;
&lt;li&gt;一个 CreateStreamFilterFactory 方法，配置解析时生成 StreamFilterFactory 就是调用它；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;1586436268990-060fa931-308c-4237-898f-463ce5a3228c.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;stream-filter-在-mosn-中是如何工作的&#34;&gt;Stream Filter 在 MOSN 中是如何工作的&lt;/h4&gt;
&lt;p&gt;接下来，我们看下 Stream Filter 在 MOSN 中是如何工作的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1586436269017-a78ea077-adea-4e5c-bb19-48843553362d.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;当 MOSN 经过协议解析，收到一个完整的请求时，会创建一个 Stream。此时收到请求的 Listener 中每存在一个 StreamFilterFactory，就会生成一个 StreamFilter 对象，随后进入到 proxy 流程。&lt;/p&gt;
&lt;p&gt;进入 proxy 流程以后，如果存在 ReceiverFilter，那么就会执行对应的逻辑，ReceiverFilter 包括两个阶段，“路由前”和“路由后”，在每个 Filter 处理完成以后，会返回一个状态，如果是 Stop 则会中止后续尚未执行的 ReceiverFilter，通常情况下，返回 Stop 状态的 Filter 都会回写一个响应。如果是 Continue 则会执行下一个 ReceiverFilter，直到本阶段的 ReceiverFilter 都执行完成或中止；路由前阶段的 ReceiverFIlter 执行完成后，就会执行路由后阶段，其逻辑和路由前一致。如果是正常转发，那么随后 MOSN 会收到一个响应或者发现其他异常直接回写一个响应，此时就会进入到 SenderFilter 的流程中，完成 SenderFilter 的处理。SenderFilter 处理完成以后，MOSN 会写响应给 Client，并且完成最后的收尾工作，收尾工作包括一些数据的回收、日志的记录，以及 StreamFilter 的“销毁”（调用 OnDestroy）。&lt;/p&gt;
&lt;h4 id=&#34;stream-filter-demo&#34;&gt;Stream Filter Demo&lt;/h4&gt;
&lt;p&gt;对 StreamFilter 有了一个基本的认识以后，我们来看一个实际的 Demo 代码来看下如何实现一个 StreamFilter 并且让它在 MOSN 中发挥作用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1586436268993-74f02195-c831-4c42-9736-d9eaf7b26cb7.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;按照刚才我们的介绍，一个 Stream FIlter 要包含三部分：Filter、Factory、CreateFactory。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先我们实现一个 Filter，其逻辑是模拟一个鉴权的 Filter：只有请求的 Header 中包含所配置的 Key-Value 时，MOSN 才会对请求做继续转发，否则直接返回 403 错误；&lt;/li&gt;
&lt;li&gt;然后我们实现一个 Factory，它负责生成我们实现的 Filter，并且说明 Filter 应该发挥作用的阶段（在请求阶段、路由匹配之前）；&lt;/li&gt;
&lt;li&gt;最后我们定义了一个生成 DemoFactory 的函数 CreateDemoFactory，并且通过 init 将其“注册”，注册完成以后，MOSN 配置解析就可以识别这个 StreamFilter；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;1586436269034-bac1b72c-84cd-48c8-9e73-4867587ee28d.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;完成实现以后，我们就可以通过具体的配置来实现对应的功能了。在示例的配置中，配置 StreamFilter 为我们刚才实现的 Filter，只转发 Header 中包含 user:admin 的请求。示例配置中监听的端口是 2046，转发的后端 server 端口是 8080。在演示之前，我已经完成了 8080 server 的启动，这个 server 会对收到的任意请求返回 200 。我们来看一下 MOSN 转发情况。Demo 操作可以在文末直播的视频回顾中查看。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stream Filter Demo: &lt;a href=&#34;https://github.com/mosn/mosn/tree/master/examples/codes/mosn-extensions/simple_streamfilter&#34;&gt;https://github.com/mosn/mosn/tree/master/examples/codes/mosn-extensions/simple_streamfilter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Demo Readme：&lt;a href=&#34;https://github.com/mosn/mosn/tree/master/examples/cn_readme/mosn-extensions&#34;&gt;https://github.com/mosn/mosn/tree/master/examples/cn_readme/mosn-extensions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mosn-plugin-机制&#34;&gt;MOSN Plugin 机制&lt;/h3&gt;
&lt;p&gt;下面我们来了解一下 MOSN 的 Plugin 机制。&lt;/p&gt;
&lt;p&gt;刚才我们对 Stream Filter 有了一个了解，MOSN 中其余的扩展实现也是类似的方法，思路就是编码实现 MOSN 扩展点所需要的接口然后利用 MOSN 的框架运行扩展的实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1586436268983-cccb6022-61e0-491c-8dd6-5d1c67a31d02.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是这里会发现一个问题，就是有时候我们需要的扩展能力已经有现成可用的实现了，那么我们是否可以做简单的改造就让 MOSN 可以获取对应的能力，哪怕目前可用的实现不是 Go 语言的实现，比如现成的限流能力的实现、注入能力的实现等；又或者对于某些特定的能力，它需要有更严格的控制，更高的标准，比如安全相关的能力。&lt;/p&gt;
&lt;p&gt;类似这样的场景，我们引入了 MOSN 的 Plugin 机制，它支持我们可以对 MOSN 需要的能力进行独立开发或者我们对现有的程序进行适当的改造以后，就可以将它们引入到 MOSN 当中来。&lt;/p&gt;
&lt;p&gt;MOSN 的 Plugin 机制包含了两部分内容，一是 MOSN 自定义的 Plugin 框架，它支持通过在 MOSN 中实现 agent 与一个独立的进程进行交互来完成 MOSN 扩展能力的实现。二是基于 Golang 的 Plugin 框架，通过动态库（SO）加载的方式，实现 MOSN 的扩展。其中动态库加载的方式目前还存在一些局限性，还处于 beta 阶段。&lt;/p&gt;
&lt;p&gt;我们先来看一下多进程 Plugin 框架。&lt;/p&gt;
&lt;h4 id=&#34;多进程-plugin-框架&#34;&gt;多进程 Plugin 框架&lt;/h4&gt;
&lt;p&gt;MOSN 的 Plugin 框架是 MOSN 封装的一个可以让 MOSN 通过 gRPC 和独立进程进行交互的方式，它包含两部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;独立的进程通过 MOSN Plugin 框架管理，作为 MOSN 的子进程；MOSN 的 Plugin 框架可以管理它们，如启动、关闭等；&lt;/li&gt;
&lt;li&gt;通过在 MOSN 中实现的 agent，使用 gRPC 的方式和子进程进行交互，gRPC 可以是基于 tcp 的，也可以是基于 domain socket 的；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;1586436268954-38e37509-fbf8-44f4-a0fe-0860401daae0.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;基于这个框架，我们只需要开发或者进行一些改造，让程序满足 MOSN 框架的规范，就可以作为 MOSN 多进程插件的一部分。&lt;/p&gt;
&lt;p&gt;首先我们需要提供一个 gRPC 的服务，并且满足 MOSN 框架下的 proto 定义。当 gRPC server 启动完成以后，向标准输出（stdout）输出一段约定的字符串，作为 MOSN 和子进程之间的握手协议。MOSN 中的对应 agent 会通过握手协议完成与子进程之间的连接建立。握手协议的字符串包含5个字段，每个字段之间用&amp;quot;|&amp;ldquo;分割，其中带$符号的是根据实际进程情况需要填写的值，其余的是当前约定的固定字段。network 支持 tcp/unix，代表通过 tcp 方式还是 unix domain socket 的方式进行通信，addr 表示 gRPC server 监听的地址。&lt;/p&gt;
&lt;p&gt;MOSN 提供了 go 语言的子进程 server 封装，在 go 语言场景下，作为子进程的程序只需要实现一个 MOSN 框架下的 plugin.Service 接口，并且通过 plugin.Serve 方法启动即可。&lt;/p&gt;
&lt;p&gt;通过 Plugin 框架，让 MOSN 做到在扩展功能实现的时候，支持隔离性、支持异构语言扩展能力、支持模块化，以及具备进程管理的能力。&lt;/p&gt;
&lt;p&gt;对于 MOSN 通过多进程方式完成扩展，今天准备了两个示例和大家进行分享。一个是基于 MOSN 的 TLS 扩展，模拟了通过一个安全等级比较高的证书管理程序来获取 TLS 配置证书、私钥等敏感信息的能力；第二个是将之前演示的 Stream Filter 修改为了“子进程”，模拟“如何将现成的能力”引入 MOSN。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于 MOSN 的 TLS 扩展示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先来看 TLS 的扩展，示例包含两部分内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独立的子进程，用 Go 语言实现，实现了 plugin.Service 接口，并通过 plugin.Serve 方法启动；&lt;/li&gt;
&lt;li&gt;MOSN 扩展点实现交互 agent。在这里就不详细展开TLS扩展点的细节了，只关注交互过程：通过 Call 方法发送 gRPC 请求，获取响应，完成相关逻辑；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;1586436269094-79115a60-66ca-4318-9049-82079bae5979.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;load cert demo: &lt;a href=&#34;https://github.com/mosn/mosn/tree/master/examples/codes/mosn-extensions/plugin/cert_loader&#34;&gt;https://github.com/mosn/mosn/tree/master/examples/codes/mosn-extensions/plugin/cert_loader&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Demo Readme：&lt;a href=&#34;https://github.com/mosn/mosn/tree/master/examples/cn_readme/mosn-extensions&#34;&gt;https://github.com/mosn/mosn/tree/master/examples/cn_readme/mosn-extensions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们来看一下效果，首先配置依然是监听 2046 的端口，配置了扩展的 TLS 配置，就需要 HTTPS 才可以访问 MOSN。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stream Filter 作为 agent 示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面我们来看下 Stream Filter 作为 agent，与多进程之间的示例，模拟“如何将现成的能力”引入 MOSN。在示例中我们把之前的“鉴权”认为是一个“现成的”能力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1586436268973-4fe309cb-83dc-41d8-9bff-0887cf08d68a.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;独立进程中实现和之前一样的“鉴权”能力，其配置来自进程的启动参数。Stream Filter 作为 agent 实现，其中“校验”逻辑修改为和子进程交互，在生成 Factory 时完成子进程的启动和配置设置。&lt;/p&gt;
&lt;p&gt;这个示例运行以后和之前 Stream Filter 的效果是一样的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stream Filter Plugin demo: &lt;a href=&#34;https://github.com/mosn/mosn/tree/master/examples/codes/mosn-extensions/plugin/filter&#34;&gt;https://github.com/mosn/mosn/tree/master/examples/codes/mosn-extensions/plugin/filter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Demo Readme：&lt;a href=&#34;https://github.com/mosn/mosn/tree/master/examples/cn_readme/mosn-extensions&#34;&gt;https://github.com/mosn/mosn/tree/master/examples/cn_readme/mosn-extensions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;动态库so扩展机制&#34;&gt;动态库(SO)扩展机制&lt;/h4&gt;
&lt;p&gt;在目前的多进程框架中，虽然扩展能力可以通过一个独立的子程序实现，但是仍然需要在 MOSN 中实现一个 agent 用于交互，依然需要在MOSN中编写一部分代码；而我们希望引入动态库（SO）加载的机制，实现在不重新编译 MOSN 的情况下，通过加载不同的 SO，做到不同的扩展能力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1586436268988-2b2d72f0-ce06-4678-ba14-ec1b73bb85a9.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;与子程序模式相比，SO 虽然也是一个独立的二进制，但是最终启动的时候，不会有额外的子进程存在，其生命周期可以和 MOSN 完全保持一致，而且动态库机制还有一个优势：它可以让扩展代码和 MOSN 完全解耦合。&lt;/p&gt;
&lt;p&gt;但是，目前使用动态库加载的方式还存在一些限制，因此 MOSN 对于这个能力也还处于 Beta 阶段，并没有投入实际使用，需要完善。相关的原因包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;部分 MOSN 扩展的实现需要用到 MOSN 中的一些定义，因此在动态库实现时不能完全做到解耦合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决这个问题，MOSN 将一些基础库（如日志、buffer 等），一些 API 定义从 MOSN 的核心仓库中独立出来，这样扩展实现和 MOSN 核心都引用这些“独立”的库，减少扩展对 MOSN 核心代码的依赖。&lt;/p&gt;
&lt;p&gt;如果某一个扩展点要支持完全解耦合的动态库扩展，那么对应的扩展点都需要进行支持动态库加载的改造，包括配置模型与实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MOSN 动态库加载的方式，其实是基于 Go 语言的 plugin 包实现的，它可以加载用 Go 语言编译的动态库。但是对于动态库的编译环境存在一些限制，编译它时必须和 MOSN 编译时的 GOPATH 保持一致；同时引用的代码路径都需要保持一致，如果存在 vendor 目录，那么意味着编译动态库时的项目路径也得和 MOSN 核心保持一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决这个问题，我们考虑使用 Docker 编译，在编译时统一 GOPATH，强制修改代码目录结构，屏蔽掉 Vendor 目录差异的方式来解决，这种方式目前仍然在验证中。&lt;/p&gt;
&lt;p&gt;因此理论上 MOSN 目前所有的扩展点都可以使用 Go 语言原生机制通过加载 SO 的方式来实现，而目前 MOSN 最适合实现这个能力的一个扩展点就是 Stream Filter。&lt;/p&gt;
&lt;p&gt;我们只需要实现一个通用的、可以加载 SO 的 Filter，然后在具体的 SO 中实现真正的 StreamFilter 逻辑，由于 StreamFilter 实现所需要的接口定义都在 mosn.io/api 中，所以 SO 可以做到和 MOSN 核心框架解耦合。&lt;/p&gt;
&lt;p&gt;关键点就是这个通用 Filter 的设计和实现，我们也通过 Demo 来看一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通用 Filter 的设计和实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个通用的 Filter 和普通的 StreamFilter 不同，它只包含一个要素：CreateFactory。思路是通过通用的 CreateFactory，加载 SO 中的 CreateFactory 并执行，让 SO 中的 Factory 发挥作用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1586436269013-7a2935b1-37f5-45c2-9e96-f11f62ed8bee.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;通用 CreateFactory 包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置解析，解析出两部分内容：一是需要加载的 SO 路径，二是 SO 中对应 Filter 所需要的配置；&lt;/li&gt;
&lt;li&gt;SO 路径就代表了 SO 中 Filter 的“注册”，以及本次会选择这个 Filter；&lt;/li&gt;
&lt;li&gt;加载 SO，基于其中约定好的函数名，获取真正的 CreateFactory 函数；&lt;/li&gt;
&lt;li&gt;调用真正的 CreateFactory 函数，实现 SO 中 StreamFilter 的加载；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此，我们可以看到，SO 中的 StreamFIlter 也和普通的 FIlter 有些区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;生成 StreamFilterChainFactory 的函数必须是固定的名字；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不再需要 init “注册”该函数；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stream Filter SO Demo: &lt;a href=&#34;https://github.com/mosn/mosn/tree/master/examples/codes/mosn-extensions/plugin/so&#34;&gt;https://github.com/mosn/mosn/tree/master/examples/codes/mosn-extensions/plugin/so&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Demo Readme：&lt;a href=&#34;https://github.com/mosn/mosn/tree/master/examples/cn_readme/mosn-extensions&#34;&gt;https://github.com/mosn/mosn/tree/master/examples/cn_readme/mosn-extensions&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们来看一下这个 Demo 的效果。本次 Demo 中的 Filter 实现依然是之前的“鉴权”示例。经过验证，我们发现这个思路是可行的，但是离生产实践还需要完善更多的细节。&lt;/p&gt;
&lt;h3 id=&#34;代码扩展活动&#34;&gt;代码扩展活动&lt;/h3&gt;
&lt;p&gt;经过这些演示，相信大家对 MOSN 的扩展能力也有所了解了，这里我们来做一个代码扩展活动，希望大家可以踊跃参与。完成活动任务，提交相关代码 PR 到 MOSN 的仓库，我们会进行 CodeReview 和验证，第一个验证通过的代码将合并到 MOSN 的 example 中，并且对提交的同学送上一份奖励；对于前3名提交、同样结果正确并且是原创的，虽然我们不能合并对应的代码，但是我们也将送上奖励。&lt;/p&gt;
&lt;p&gt;活动任务共有五个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多进程 Demo 中证书加载的独立进程，使用 python 或者 java 实现以后，demo 运行演示成功。任意一种语言就算完成一个任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;examples/codes/mosn-extensions/plugin/cert_loader/python/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;examples/codes/mosn-extensions/plugin/cert_loader/java/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;多进程 Demo 中 stream filter 的独立进程，使用 python 或者 java 实现以后，demo 运行演示成功。任意一种语言就算完成一个任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;examples/codes/mosn-extensions/plugin/filter/python/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;examples/codes/mosn-extensions/plugin/filter/java/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;SO 动态加载 Demo 中，SO 里实现的 Stream Filter 结合多进程框架（GO 语言）实现，Demo 运行演示成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;examples/codes/mosn-extensions/plugin/so/subprocess/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;跨语言相关的实现可以参考以下示例：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/mosn/mosn/tree/master/examples/codes/plugin/across-languages/server/&#34;&gt;https://github.com/mosn/mosn/tree/master/examples/codes/plugin/across-languages/server/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;规划与展望&#34;&gt;规划与展望&lt;/h3&gt;
&lt;p&gt;最后向大家介绍一下 MOSN 后续扩展能力的规划，也希望大家有需求的可以向我们反馈，有兴趣的一起参与到 MOSN 的建设中来。首先就是要完善 SO 动态库加载机制，让 MOSN 支持 SO 方式加载扩展；然后就是针对 LUA 的脚本扩展以及支持 WASM 的扩展能力；最后 MOSN 还会增加更多的扩展点，以满足更多更复杂的场景。非常欢迎大家参与到 MOSN 社区的共建中。&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
